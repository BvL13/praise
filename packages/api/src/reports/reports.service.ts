import { Injectable } from '@nestjs/common';
import { Octokit } from '@octokit/rest';
import { ApiException } from '../shared/exceptions/api-exception';
import { errorMessages } from '../shared/exceptions/error-messages';
import { ReportManifestDto } from './dto/report-manifest.dto';
import { Model, Types } from 'mongoose';
import { Praise, PraiseSchema } from '../praise/schemas/praise.schema';
import { queryOpenAi } from '../shared/query-open-ai';
import {
  UserAccount,
  UserAccountSchema,
} from '../useraccounts/schemas/useraccounts.schema';
import { User } from '../users/schemas/users.schema';
import { DbService } from '../database/services/db.service';

const PROMPT_SUMMARY = `Below is a table of praise items describing contributions made by community member {user}. Summarize, what kind of work does {user} do for the community? The first column is a score representing the impact of the contribution, the second column describes the contribution. The higher impact score a contribution has the more it impacts your description of {user}. Also comment when in time contributions were made. The older the less impactful a contribution is. Max 400 characters. Paragraphs separated by "\n". Max 3 paragraphs.`;

const PROMPT_LABEL = `Below is a table of praise items describing contributions made by a community member. The first column is a score representing the impact of the contribution, the second column describes the contribution. Create a comma separated list of labels that describe the most impactful work this contributor does for the community. The higher impact score a contribution has the more it impacts your description. A label can consist of at max two words. 7 labels please.`;

@Injectable()
export class ReportsService {
  private octokit: Octokit;
  private owner = 'givepraise';
  private repo = 'reports';
  private basePath = 'reports';

  private userAccountModel: Model<UserAccount>;
  private praiseModel: Model<Praise>;

  constructor(private dbService: DbService) {
    this.octokit = new Octokit({
      userAgent: 'Praise API',
    });
    this.userAccountModel = this.dbService.getModel<UserAccount>(
      UserAccount.name,
      UserAccountSchema,
    );
    this.praiseModel = this.dbService.getModel<Praise>(
      Praise.name,
      PraiseSchema,
    );
  }

  async listAllReports(): Promise<ReportManifestDto[]> {
    try {
      const reportsDirs = await this.octokit.repos.getContent({
        owner: this.owner,
        repo: this.repo,
        path: this.basePath,
      });

      const manifestsPromises = (reportsDirs.data as any)
        .filter((item: { type: string }) => item.type === 'dir')
        .map(async (dir: { name: any }) => {
          try {
            const manifest = await this.octokit.repos.getContent({
              owner: this.owner,
              repo: this.repo,
              path: `${this.basePath}/${dir.name}/manifest.json`,
            });

            const content = Buffer.from(
              (manifest.data as any).content,
              'base64',
            ).toString();

            return JSON.parse(content);
          } catch (error) {
            throw new ApiException(
              errorMessages.REPORTS_LIST_ERROR,
              `Error fetching manifest for ${dir.name}: ${error.message}`,
            );
          }
        });

      return Promise.all(manifestsPromises);
    } catch (error) {
      throw new ApiException(
        errorMessages.REPORTS_LIST_ERROR,
        `Error fetching report directories: ${error.message}`,
      );
    }
  }

  /**
   *  Generate a bio for a community member based on their praise. Bio is
   *  generated by OpenAI.
   */
  async getReceiverBio(userAccountId: Types.ObjectId) {
    if (!process.env.OPENAI_KEY) {
      throw new ApiException(
        errorMessages.CONFIGURATION_ERROR,
        'OpenAI API key needs to be set.',
      );
    }

    // Get user account details to get user name
    const userAccount = await this.userAccountModel
      .findById(userAccountId.toString())
      .populate('user');

    if (!userAccount) {
      throw new ApiException(errorMessages.USER_ACCOUNT_NOT_FOUND);
    }

    // Get the top 100 praise for the user
    const praise = await this.praiseModel.find(
      {
        receiver: userAccountId,
      },
      null,
      { limit: 100, sort: { score: -1 } },
    );

    if (!praise) {
      throw new ApiException(errorMessages.PRAISE_NOT_FOUND);
    }

    if (praise.length < 10) {
      throw new ApiException(
        errorMessages.PRAISE_NOT_ENOUGH,
        'Contributor have note received enough praise to generate a bio.',
      );
    }

    // Turn these praise into CSV for OpenAI
    const topPraiseCsv =
      'date.getTime, impact score, reason\n' +
      praise
        .map((p) => `${p.createdAt.getTime()}, ${p.score}, ${p.reason}`)
        .join('\n');

    // Make the prompt personal
    const prompt = PROMPT_SUMMARY.replace(
      /{user}/g,
      (userAccount.user as User).username || userAccount.name,
    );

    return await queryOpenAi(topPraiseCsv, prompt, process.env.OPENAI_KEY);
  }

  /**
   *  Generate descriptive labels a community member based on the praise they
   *  have received. Labels are generated by OpenAI.
   */
  async getReceiverLabels(userAccountId: Types.ObjectId) {
    if (!process.env.OPENAI_KEY) {
      throw new ApiException(
        errorMessages.CONFIGURATION_ERROR,
        'OpenAI API key needs to be set.',
      );
    }

    // Get the top 100 praise for the user
    const praise = await this.praiseModel.find(
      {
        receiver: userAccountId,
      },
      null,
      { limit: 100, sort: { score: -1 } },
    );

    if (!praise) {
      throw new ApiException(errorMessages.PRAISE_NOT_FOUND);
    }

    if (praise.length < 10) {
      throw new ApiException(
        errorMessages.PRAISE_NOT_ENOUGH,
        'Contributor have note received enough praise to generate labels.',
      );
    }

    // Turn these praise into CSV for OpenAI
    const topPraiseCsv =
      'impact score, reason\n' +
      praise.map((p) => `${p.score}, ${p.reason}`).join('\n');

    return await queryOpenAi(
      topPraiseCsv,
      PROMPT_LABEL,
      process.env.OPENAI_KEY,
    );
  }
}
